# Add AI-Discoverable Documentation Headers to Template Files

**Issue**: #308
**Parent**: #1 - Project Roadmap
**Labels**: `task`, `roadmap`, `documentation`, `templates`, `enhancement`
**Time Estimate**: 2-4 hours

## Problem Statement

We use Tera templates for provisioning, configuring, and deploying services (Docker Compose, Caddy, Prometheus, Grafana, tracker config, etc.). These templates are:

1. **Source templates** in `templates/` - used during development
2. **Generated config files** in production installations - only the rendered output exists

We're refactoring template documentation to move it from template files to Rust wrapper types (doc.rs format). This improves documentation quality and ensures it's published with each release. However, this creates a **discoverability problem for AI agents** in two scenarios:

### Scenario 1: Development Time

AI agents working on the Tracker Deployer codebase have access to the full repo. They can search for documentation, but may not know where to look for the Rust wrapper that corresponds to a template file.

**Current state**: Template files have inline comments, but no pointer to the Rust wrapper.

### Scenario 2: Production Time (Critical)

AI agents helping administrators troubleshoot or modify deployed configurations only see the **rendered output files** - not the source repo. They have no way to find:

- What the original template was
- What configuration options exist
- What the valid values are
- Where to find documentation

**Example**: An admin asks an AI agent to help configure `docker-compose.yml` on a production server. The agent sees the rendered file but has no context about the template that generated it or the documentation for valid configurations.

## Proposed Solution

Add a standardized documentation header to all template files that provides:

1. **Repository URL** - Where to find the source code
2. **Template source path** - The original template file location
3. **Rust wrapper path** - The corresponding Rust context/wrapper module
4. **Documentation URL** - Link to docs.rs documentation for the wrapper
5. **Brief description** - What this template/config does

### Header Format (YAML-style comment block)

For YAML/TOML templates:

```yaml
# ============================================================================
# Torrust Tracker Deployer - Generated Configuration
# ============================================================================
#
# This file was generated by the Torrust Tracker Deployer.
# Generated at: {{ metadata.generated_at }}
#
# DOCUMENTATION:
#   Repository:    https://github.com/torrust/torrust-tracker-deployer
#   Template:      templates/docker-compose/docker-compose.yml.tera
#   Rust Wrapper:  src/infrastructure/templating/docker_compose/template/wrappers/docker_compose/template.rs
#   API Docs:      https://docs.rs/torrust-tracker-deployer/latest/
#
# DESCRIPTION:
#   Docker Compose service definitions for Torrust Tracker deployment.
#   Includes tracker, optional MySQL, Prometheus, Grafana, and Caddy services.
#
# For configuration options and valid values, see the API documentation link above.
# ============================================================================
```

For TOML templates:

```toml
# ============================================================================
# Torrust Tracker Configuration
# ============================================================================
#
# This file was generated by the Torrust Tracker Deployer.
# Generated at: {{ metadata.generated_at }}
#
# DOCUMENTATION:
#   Repository:    https://github.com/torrust/torrust-tracker-deployer
#   Template:      templates/tracker/tracker.toml.tera
#   Rust Wrapper:  src/infrastructure/templating/tracker/template/wrapper/tracker_config/context.rs
#   API Docs:      https://docs.rs/torrust-tracker-deployer/latest/
#
# DESCRIPTION:
#   Torrust Tracker configuration file. Controls tracker behavior, database,
#   UDP/HTTP trackers, and API endpoints.
#
# For configuration options and valid values, see the API documentation link above.
# ============================================================================
```

**Note**: The timestamp uses ISO 8601 format (e.g., `2026-01-27T14:30:00Z`) and is only included in dynamic `.tera` templates. Static templates (if any) will omit the timestamp line.

## Templates to Update

| Template                                           | Rust Wrapper                                                                                |
| -------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| `templates/docker-compose/docker-compose.yml.tera` | `src/infrastructure/templating/docker_compose/template/wrappers/docker_compose/template.rs` |
| `templates/docker-compose/.env.tera`               | `src/infrastructure/templating/docker_compose/template/wrappers/env/template.rs`            |
| `templates/tracker/tracker.toml.tera`              | `src/infrastructure/templating/tracker/template/wrapper/tracker_config/template.rs`         |
| `templates/caddy/Caddyfile.tera`                   | `src/infrastructure/templating/caddy/template/wrapper/caddyfile/` (needs template.rs)       |
| `templates/prometheus/prometheus.yml.tera`         | `src/infrastructure/templating/prometheus/template/wrapper/prometheus_config/template.rs`   |
| `templates/grafana/datasources.yml.tera`           | `src/infrastructure/templating/grafana/template/wrapper/datasource/template.rs`             |
| `templates/ansible/inventory.yml.tera`             | `src/infrastructure/templating/ansible/template/wrappers/inventory/template.rs`             |
| `templates/ansible/variables.yml.tera`             | `src/infrastructure/templating/ansible/template/wrappers/variables/template.rs`             |
| `templates/tofu/*/variables.tf.json.tera`          | Provider-specific wrappers in `src/infrastructure/templating/tofu/template/providers/`      |

## Benefits

### For AI Agents

1. **Immediate context** - Agent knows where to find documentation without searching
2. **Cross-environment support** - Works in development AND production
3. **Version-aware** - docs.rs links are versioned with releases
4. **Self-documenting** - Even without AI, humans can find relevant docs

### For Developers

1. **Clear mapping** - Easy to find the Rust wrapper for any template
2. **Consistent pattern** - All templates follow the same documentation structure
3. **Maintainability** - Single source of truth (Rust docs) with clear pointers

### For System Administrators

1. **Troubleshooting aid** - Know where to look for valid configuration options
2. **AI assistance** - AI agents can help with configuration knowing the constraints
3. **Version tracking** - Know which deployer version generated the config

## Implementation Considerations

### Header in Template vs. Rendered Output

The header should be in the **template file** so it appears in the **rendered output**. This ensures production configs include the documentation links.

### Static vs. Dynamic Templates

- **Dynamic templates** (`.tera` files): Include full header with timestamp
- **Static templates** (if any): Include header without timestamp to avoid forcing all templates to be dynamic

### Metadata Context Field

Add a `metadata` field to each template context, similar to the existing `topology` field pattern:

```rust
pub struct ExampleTemplateContext {
    /// Template metadata (generation timestamp, etc.)
    ///
    /// Flattened for template compatibility - serializes metadata at top level.
    #[serde(flatten)]
    pub metadata: TemplateMetadata,

    // ... rest of context fields
}
```

The `TemplateMetadata` struct should contain:

- `generated_at: String` - ISO 8601 timestamp (e.g., `2026-01-27T14:30:00Z`)

### Timestamp Generation

- **When**: Generate timestamp when building context in project generator
- **Where**: Project generator level (inject clock service in constructor)
- **Why**: Consistent across all templates in deployment; templates don't change dynamically after process starts

### Documentation URLs

Use short-form docs.rs URLs for maintainability:

- Format: `https://docs.rs/torrust-tracker-deployer/latest/`
- Avoids long, brittle module paths that break on refactoring

## Related Documentation

- [Template System Architecture](../../docs/contributing/templates/template-system-architecture.md)
- [Tera Template Guide](../../docs/contributing/templates/tera.md)

## Already Implemented: Inline Network Descriptions

As a first step toward self-documenting rendered files, we've implemented inline network descriptions in docker-compose.yml. The `Network` enum now has a `description()` method that provides short purpose strings for each network type:

| Network       | Description                                 |
| ------------- | ------------------------------------------- |
| Database      | `Database isolation: Tracker ‚Üî MySQL`       |
| Metrics       | `Metrics scraping: Tracker ‚Üî Prometheus`    |
| Visualization | `Dashboard queries: Prometheus ‚Üî Grafana`   |
| Proxy         | `TLS termination: Caddy ‚Üî backend services` |

These descriptions are rendered as YAML comments in the generated docker-compose.yml:

```yaml
networks:
  # Database isolation: Tracker ‚Üî MySQL
  db_network:
    driver: bridge
  # Metrics scraping: Tracker ‚Üî Prometheus
  metrics_network:
    driver: bridge
```

**Implementation details:**

- `src/domain/topology/network.rs` - `Network::description()` method
- `context/network_definition.rs` - `NetworkDefinition.description` field
- `templates/docker-compose/docker-compose.yml.tera` - Renders `# {{ net.description }}`

This pattern can be extended to other configuration elements (services, volumes, etc.) as we implement the full documentation headers.

## Implementation Plan

### Phase 1: Infrastructure Setup

1. **Create `TemplateMetadata` struct**
   - Location: `src/infrastructure/templating/shared/` (or similar)
   - Fields: `generated_at: String`
   - Serialization: Flatten with `#[serde(flatten)]`

2. **Update project generators**
   - Inject clock service in constructors
   - Generate timestamp when building contexts
   - Pass metadata to all template contexts

3. **Update template context structs**
   - Add `metadata: TemplateMetadata` field at top
   - Mark with `#[serde(flatten)]`
   - Update context builders to accept metadata

### Phase 2: Template Updates

1. **Add headers to all `.tera` templates**
   - Follow standardized format with timestamp
   - Update documentation links (use short-form docs.rs URLs)
   - Include description specific to each template

2. **Verify rendered output**
   - Run E2E tests to ensure headers appear correctly
   - Check timestamp format is ISO 8601
   - Verify all template variables resolve

### Phase 3: Documentation

1. **Document the header pattern**
   - Update `docs/contributing/templates/template-system-architecture.md`
   - Add examples to template contribution guide
   - Document metadata field pattern

## Acceptance Criteria

> **Note for Contributors**: These criteria define what the PR reviewer will check. Use this as your pre-review checklist before submitting the PR to minimize back-and-forth iterations.

**Quality Checks**:

- [ ] Pre-commit checks pass: `./scripts/pre-commit.sh`

**Task-Specific Criteria**:

- [ ] `TemplateMetadata` struct created with `generated_at` field
- [ ] All project generators inject clock service and generate timestamps
- [ ] All template context structs include `metadata` field at top (with `#[serde(flatten)]`)
- [ ] All `.tera` templates include standardized documentation header
- [ ] Headers contain correct repository URL, template path, Rust wrapper path, and docs.rs URL
- [ ] Timestamp appears in rendered output in ISO 8601 format
- [ ] E2E tests pass with new headers in place
- [ ] Template contribution guide updated with header pattern documentation

## üèóÔ∏è Architecture Requirements

**DDD Layers**: Infrastructure (template system) + Domain (metadata model)
**Module Paths**:

- Metadata struct: `src/domain/templating/metadata.rs` or `src/infrastructure/templating/shared/metadata.rs`
- Project generators: `src/infrastructure/templating/*/template/renderer/project_generator.rs`
- Template contexts: `src/infrastructure/templating/*/template/wrapper/*/template.rs`

**Patterns**: Template rendering infrastructure with domain metadata

### Architectural Constraints

- [ ] Metadata struct should be domain-level or shared infrastructure
- [ ] Clock service injection follows existing dependency injection patterns
- [ ] Flattened serialization maintains template compatibility
- [ ] No breaking changes to existing template contexts

### Related Architectural Documentation

- [Template System Architecture](../contributing/templates/template-system-architecture.md)
- [Tera Template Guide](../contributing/templates/tera.md)

## Postponed Features

The following features are **not included** in this initial implementation but may be added in future iterations:

1. **Deployer version in header** - Including the version (e.g., from `Cargo.toml`) would help track which deployer version generated a config. However, this adds complexity and is not critical for the initial AI discoverability goal.
   - Potential format: `# Deployer Version: {{ metadata.deployer_version }}`
   - Would require version injection across all contexts
   - Deferred until there's a clear use case
