# Add AI-Discoverable Documentation Headers to Template Files

**Issue**: #308
**Parent**: #1 - Project Roadmap
**Labels**: `task`, `roadmap`, `documentation`, `templates`, `enhancement`
**Time Estimate**: 2-4 hours

## Problem Statement

We use Tera templates for provisioning, configuring, and deploying services (Docker Compose, Caddy, Prometheus, Grafana, tracker config, etc.). These templates are:

1. **Source templates** in `templates/` - used during development
2. **Generated config files** in production installations - only the rendered output exists

We're refactoring template documentation to move it from template files to Rust wrapper types (doc.rs format). This improves documentation quality and ensures it's published with each release. However, this creates a **discoverability problem for AI agents** in two scenarios:

### Scenario 1: Development Time

AI agents working on the Tracker Deployer codebase have access to the full repo. They can search for documentation, but may not know where to look for the Rust wrapper that corresponds to a template file.

**Current state**: Template files have inline comments, but no pointer to the Rust wrapper.

### Scenario 2: Production Time (Critical)

AI agents helping administrators troubleshoot or modify deployed configurations only see the **rendered output files** - not the source repo. They have no way to find:

- What the original template was
- What configuration options exist
- What the valid values are
- Where to find documentation

**Example**: An admin asks an AI agent to help configure `docker-compose.yml` on a production server. The agent sees the rendered file but has no context about the template that generated it or the documentation for valid configurations.

## Proposed Solution

Add a standardized documentation header to all template files that provides:

1. **Repository URL** - Where to find the source code
2. **Template source path** - The original template file location
3. **Rust wrapper path** - The corresponding Rust context/wrapper module
4. **Documentation URL** - Link to docs.rs documentation for the wrapper
5. **Brief description** - What this template/config does

### Header Format (YAML-style comment block)

For YAML/TOML templates:

```yaml
# ============================================================================
# Torrust Tracker Deployer - Generated Configuration
# ============================================================================
#
# This file was generated by the Torrust Tracker Deployer.
# Generated at: {{ metadata.generated_at }}
#
# DOCUMENTATION:
#   Repository:    https://github.com/torrust/torrust-tracker-deployer
#   Template:      templates/docker-compose/docker-compose.yml.tera
#   Rust Wrapper:  src/infrastructure/templating/docker_compose/template/wrappers/docker_compose/template.rs
#   API Docs:      https://docs.rs/torrust-tracker-deployer/latest/
#
# DESCRIPTION:
#   Docker Compose service definitions for Torrust Tracker deployment.
#   Includes tracker, optional MySQL, Prometheus, Grafana, and Caddy services.
#
# For configuration options and valid values, see the API documentation link above.
# ============================================================================
```

For TOML templates:

```toml
# ============================================================================
# Torrust Tracker Configuration
# ============================================================================
#
# This file was generated by the Torrust Tracker Deployer.
# Generated at: {{ metadata.generated_at }}
#
# DOCUMENTATION:
#   Repository:    https://github.com/torrust/torrust-tracker-deployer
#   Template:      templates/tracker/tracker.toml.tera
#   Rust Wrapper:  src/infrastructure/templating/tracker/template/wrapper/tracker_config/context.rs
#   API Docs:      https://docs.rs/torrust-tracker-deployer/latest/
#
# DESCRIPTION:
#   Torrust Tracker configuration file. Controls tracker behavior, database,
#   UDP/HTTP trackers, and API endpoints.
#
# For configuration options and valid values, see the API documentation link above.
# ============================================================================
```

**Note**: The timestamp uses ISO 8601 format (e.g., `2026-01-27T14:30:00Z`) and is only included in dynamic `.tera` templates. Static templates use a simplified header without timestamp or Rust wrapper path since they are copied as-is without rendering.

## Templates to Update

### Dynamic Templates (`.tera` files)

| Template                                           | Rust Wrapper                                                                                |
| -------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| `templates/docker-compose/docker-compose.yml.tera` | `src/infrastructure/templating/docker_compose/template/wrappers/docker_compose/template.rs` |
| `templates/docker-compose/.env.tera`               | `src/infrastructure/templating/docker_compose/template/wrappers/env/template.rs`            |
| `templates/tracker/tracker.toml.tera`              | `src/infrastructure/templating/tracker/template/wrapper/tracker_config/template.rs`         |
| `templates/caddy/Caddyfile.tera`                   | `src/infrastructure/templating/caddy/template/wrapper/caddyfile/` (needs template.rs)       |
| `templates/prometheus/prometheus.yml.tera`         | `src/infrastructure/templating/prometheus/template/wrapper/prometheus_config/template.rs`   |
| `templates/grafana/datasources.yml.tera`           | `src/infrastructure/templating/grafana/template/wrapper/datasource/template.rs`             |
| `templates/ansible/inventory.yml.tera`             | `src/infrastructure/templating/ansible/template/wrappers/inventory/template.rs`             |

### Static Templates (no `.tera` extension)

Static templates that are copied as-is will use simplified headers without timestamp or Rust wrapper path.

**Note**: JSON files are excluded as they don't support comments.

| Template                                                | Description                                               |
| ------------------------------------------------------- | --------------------------------------------------------- |
| `templates/ansible/ansible.cfg`                         | Ansible global configuration settings                     |
| `templates/ansible/configure-firewall.yml`              | Ansible playbook to configure firewall rules              |
| `templates/ansible/configure-security-updates.yml`      | Ansible playbook to configure automatic security updates  |
| `templates/ansible/create-grafana-storage.yml`          | Ansible playbook to create Grafana storage directories    |
| `templates/ansible/create-mysql-storage.yml`            | Ansible playbook to create MySQL storage directories      |
| `templates/ansible/create-prometheus-storage.yml`       | Ansible playbook to create Prometheus storage directories |
| `templates/ansible/create-tracker-storage.yml`          | Ansible playbook to create Tracker storage directories    |
| `templates/ansible/deploy-caddy-config.yml`             | Ansible playbook to deploy Caddy configuration            |
| `templates/ansible/deploy-compose-files.yml`            | Ansible playbook to deploy Docker Compose files           |
| `templates/ansible/deploy-grafana-provisioning.yml`     | Ansible playbook to deploy Grafana provisioning files     |
| `templates/ansible/deploy-prometheus-config.yml`        | Ansible playbook to deploy Prometheus configuration       |
| `templates/ansible/deploy-tracker-config.yml`           | Ansible playbook to deploy Tracker configuration          |
| `templates/ansible/init-tracker-database.yml`           | Ansible playbook to initialize Tracker database           |
| `templates/ansible/install-docker.yml`                  | Ansible playbook to install Docker                        |
| `templates/ansible/install-docker-compose.yml`          | Ansible playbook to install Docker Compose                |
| `templates/ansible/run-compose-services.yml`            | Ansible playbook to run Docker Compose services           |
| `templates/ansible/update-apt-cache.yml`                | Ansible playbook to update APT package cache              |
| `templates/ansible/wait-cloud-init.yml`                 | Ansible playbook to wait for cloud-init completion        |
| `templates/grafana/provisioning/dashboards/torrust.yml` | Grafana dashboard provisioning configuration              |
| `templates/tofu/lxd/main.tf`                            | OpenTofu main configuration for LXD provider              |
| `templates/tofu/hetzner/main.tf`                        | OpenTofu main configuration for Hetzner provider          |

## Benefits

### For AI Agents

1. **Immediate context** - Agent knows where to find documentation without searching
2. **Cross-environment support** - Works in development AND production
3. **Version-aware** - docs.rs links are versioned with releases
4. **Self-documenting** - Even without AI, humans can find relevant docs

### For Developers

1. **Clear mapping** - Easy to find the Rust wrapper for any template
2. **Consistent pattern** - All templates follow the same documentation structure
3. **Maintainability** - Single source of truth (Rust docs) with clear pointers

### For System Administrators

1. **Troubleshooting aid** - Know where to look for valid configuration options
2. **AI assistance** - AI agents can help with configuration knowing the constraints
3. **Version tracking** - Know which deployer version generated the config

## Implementation Considerations

### Header in Template vs. Rendered Output

The header should be in the **template file** so it appears in the **rendered output**. This ensures production configs include the documentation links.

### Static vs. Dynamic Templates

- **Dynamic templates** (`.tera` files): Include full header with timestamp and Rust wrapper path
- **Static templates** (copied as-is): Include simplified header without timestamp or Rust wrapper path

Static templates use a simplified header format:

- Excludes: Generation timestamp, Rust wrapper path (since there's no wrapper for static files)
- Includes: Repository URL, template path, API docs link, description

Example for static template:

```properties
# ============================================================================
# Torrust Tracker Deployer - Generated Configuration
# ============================================================================
#
# This file was generated by the Torrust Tracker Deployer.
#
# DOCUMENTATION:
#   Repository:    https://github.com/torrust/torrust-tracker-deployer
#   Template:      templates/ansible/ansible.cfg
#   API Docs:      https://docs.rs/torrust-tracker-deployer/latest/
#
# DESCRIPTION:
#   This file configures global settings for Ansible when running from this directory
#
# For configuration options and valid values, see the API documentation link above.
# ============================================================================
```

### Metadata Context Field

Add a `metadata` field to each template context, similar to the existing `topology` field pattern:

```rust
pub struct ExampleTemplateContext {
    /// Template metadata (generation timestamp, etc.)
    ///
    /// Flattened for template compatibility - serializes metadata at top level.
    #[serde(flatten)]
    pub metadata: TemplateMetadata,

    // ... rest of context fields
}
```

The `TemplateMetadata` struct should contain:

- `generated_at: String` - ISO 8601 timestamp (e.g., `2026-01-27T14:30:00Z`)

### Timestamp Generation

- **When**: Generate timestamp when building context in project generator
- **Where**: Project generator level (inject clock service in constructor)
- **Why**: Consistent across all templates in deployment; templates don't change dynamically after process starts

### Documentation URLs

Use short-form docs.rs URLs for maintainability:

- Format: `https://docs.rs/torrust-tracker-deployer/latest/`
- Avoids long, brittle module paths that break on refactoring

## Related Documentation

- [Template System Architecture](../../docs/contributing/templates/template-system-architecture.md)
- [Tera Template Guide](../../docs/contributing/templates/tera.md)

## Already Implemented: Inline Network Descriptions

As a first step toward self-documenting rendered files, we've implemented inline network descriptions in docker-compose.yml. The `Network` enum now has a `description()` method that provides short purpose strings for each network type:

| Network       | Description                                 |
| ------------- | ------------------------------------------- |
| Database      | `Database isolation: Tracker ‚Üî MySQL`       |
| Metrics       | `Metrics scraping: Tracker ‚Üî Prometheus`    |
| Visualization | `Dashboard queries: Prometheus ‚Üî Grafana`   |
| Proxy         | `TLS termination: Caddy ‚Üî backend services` |

These descriptions are rendered as YAML comments in the generated docker-compose.yml:

```yaml
networks:
  # Database isolation: Tracker ‚Üî MySQL
  db_network:
    driver: bridge
  # Metrics scraping: Tracker ‚Üî Prometheus
  metrics_network:
    driver: bridge
```

**Implementation details:**

- `src/domain/topology/network.rs` - `Network::description()` method
- `context/network_definition.rs` - `NetworkDefinition.description` field
- `templates/docker-compose/docker-compose.yml.tera` - Renders `# {{ net.description }}`

This pattern can be extended to other configuration elements (services, volumes, etc.) as we implement the full documentation headers.

## Implementation Plan

### Phase 1: Infrastructure Setup

**Complete once, before implementing any template:**

1. **Create `TemplateMetadata` struct**
   - Location: `src/infrastructure/templating/metadata.rs`
   - Fields: `generated_at: DateTime<Utc>`
   - Serialization: Flatten with `#[serde(flatten)]`
   - Method: `generated_at_iso8601()` for template rendering

**Status**: ‚úÖ Complete

### Phase 2: Template Updates (One Template at a Time)

**For each template, complete all steps before moving to the next:**

1. **Select next template** from the list below
2. **Update project generator** for this specific template:
   - Inject clock service in constructor (if not already present)
   - Generate timestamp when building context: `TemplateMetadata::new(clock.now())`
   - Add metadata field to context struct
3. **Add header to template file**
   - Follow standardized format with timestamp
   - Update documentation links (use short-form docs.rs URLs)
   - Include description specific to this template
4. **Test the implementation**:
   - Run linters after template change
   - After first template: Run full pre-commit checks
   - Verify rendered output in `build/` directory has correct header
   - Review inline documentation in template (move heavy docs to Rust wrappers)
5. **Commit and move to next template**

**Templates to Update** (track progress):

- [ ] `templates/ansible/inventory.yml.tera`
- [ ] `templates/ansible/variables.yml.tera`
- [ ] `templates/caddy/Caddyfile.tera`
- [ ] `templates/docker-compose/docker-compose.yml.tera`
- [ ] `templates/grafana/provisioning/datasources/prometheus.yml.tera`
- [ ] `templates/prometheus/prometheus.yml.tera`
- [ ] `templates/tofu/common/cloud-init.yml.tera`
- [ ] `templates/tofu/hetzner/variables.tfvars.tera`
- [ ] `templates/tofu/lxd/variables.tfvars.tera`
- [x] `templates/tracker/tracker.toml.tera`

**Process for Each Tera Template**:

1. **Add AI-discoverable header**
   - Follow standardized format with timestamp
   - Update documentation links (use short-form docs.rs URLs)
   - Include description specific to each template

2. **Review and clean up comments** (Tera templates only)
   - **Keep in template**: User-facing comments that explain configuration options (e.g., "Set to true when ANY HTTP tracker uses Caddy TLS termination")
   - **Move to wrapper**: Implementation details, code documentation, developer notes
   - Rationale: Templates should contain configuration guidance, not implementation details

3. **Fix Tera delimiters to avoid extra line breaks**
   - Replace `{% if %}` with `{%- if %}` (trim whitespace before)
   - Replace `{% endif %}` with `{%- endif %}` (trim whitespace before)
   - Replace `{% for %}` with `{%- for %}` (trim whitespace before)
   - Replace `{% endfor %}` with `{%- endfor %}` (trim whitespace before)
   - Replace `{% elif %}` with `{%- elif %}` (trim whitespace before)
   - Use `-%}` (trim after) only when needed to prevent trailing blank lines
   - Pattern: Control flow statements should use `{%-` to prevent inserting blank lines

4. **Verify rendered output**
   - Run pre-commit checks which includes E2E tests that regenerate build files
   - Inspect rendered files in `build/` directory (e.g., `build/e2e-deployment/tracker/tracker.toml`)
   - Verify headers appear correctly without extra blank lines
   - Check timestamp format is ISO 8601
   - Verify all template variables resolve
   - Confirm no unwanted blank lines from control flow statements

### Phase 3: Static Template Updates

**Implementation Notes**:

- Process one template at a time
- Static templates use simplified header (no timestamp, no Rust wrapper path)
- Run linters after each template change
- These are straightforward documentation additions- **Excluded formats**: JSON files (no comment support) - `metrics.json`, `stats.json`
  **Static Templates to Update** (track progress):

- [ ] `templates/ansible/ansible.cfg`
- [ ] `templates/ansible/configure-firewall.yml`
- [ ] `templates/ansible/configure-security-updates.yml`
- [ ] `templates/ansible/create-grafana-storage.yml`
- [ ] `templates/ansible/create-mysql-storage.yml`
- [ ] `templates/ansible/create-prometheus-storage.yml`
- [ ] `templates/ansible/create-tracker-storage.yml`
- [ ] `templates/ansible/deploy-caddy-config.yml`
- [ ] `templates/ansible/deploy-compose-files.yml`
- [ ] `templates/ansible/deploy-grafana-provisioning.yml`
- [ ] `templates/ansible/deploy-prometheus-config.yml`
- [ ] `templates/ansible/deploy-tracker-config.yml`
- [ ] `templates/ansible/init-tracker-database.yml`
- [ ] `templates/ansible/install-docker.yml`
- [ ] `templates/ansible/install-docker-compose.yml`
- [ ] `templates/ansible/run-compose-services.yml`
- [ ] `templates/ansible/update-apt-cache.yml`
- [ ] `templates/ansible/wait-cloud-init.yml`
- [ ] `templates/grafana/provisioning/dashboards/torrust.yml`
- [ ] `templates/tofu/lxd/main.tf`
- [ ] `templates/tofu/hetzner/main.tf`

1. **Add simplified headers to all static templates**
   - Follow simplified header format
   - Include repository URL, template path, API docs, and description
   - Omit timestamp and Rust wrapper path

2. **Verify static templates** with timestamp

- [ ] All static templates include simplified documentation header without timestamp
- [ ] Headers contain correct repository URL, template path, and docs.rs URL
- [ ] Dynamic template headers include Rust wrapper path
- [ ] Static template headers omit Rust wrapper path (not applicable)
  - Check that files are still valid configuration files

### Phase 4: Documentation

1. **Document the header pattern**
   - Update `docs/contributing/templates/template-system-architecture.md`
   - Add examples to template contribution guide
   - Document metadata field pattern

## Acceptance Criteria

> **Note for Contributors**: These criteria define what the PR reviewer will check. Use this as your pre-review checklist before submitting the PR to minimize back-and-forth iterations.

**Quality Checks**:

- [ ] Pre-commit checks pass: `./scripts/pre-commit.sh`

**Task-Specific Criteria**:

- [ ] `TemplateMetadata` struct created with `generated_at` field
- [ ] All project generators inject clock service and generate timestamps
- [ ] All template context structs include `metadata` field at top (with `#[serde(flatten)]`)
- [ ] All `.tera` templates include standardized documentation header
- [ ] Headers contain correct repository URL, template path, Rust wrapper path, and docs.rs URL
- [ ] Timestamp appears in rendered output in ISO 8601 format
- [ ] E2E tests pass with new headers in place
- [ ] Template contribution guide updated with header pattern documentation

## üèóÔ∏è Architecture Requirements

**DDD Layers**: Infrastructure (template system) + Domain (metadata model)
**Module Paths**:

- Metadata struct: `src/domain/templating/metadata.rs` or `src/infrastructure/templating/shared/metadata.rs`
- Project generators: `src/infrastructure/templating/*/template/renderer/project_generator.rs`
- Template contexts: `src/infrastructure/templating/*/template/wrapper/*/template.rs`

**Patterns**: Template rendering infrastructure with domain metadata

### Architectural Constraints

- [ ] Metadata struct should be domain-level or shared infrastructure
- [ ] Clock service injection follows existing dependency injection patterns
- [ ] Flattened serialization maintains template compatibility
- [ ] No breaking changes to existing template contexts

### Related Architectural Documentation

- [Template System Architecture](../contributing/templates/template-system-architecture.md)
- [Tera Template Guide](../contributing/templates/tera.md)

## Postponed Features

The following features are **not included** in this initial implementation but may be added in future iterations:

1. **Deployer version in header** - Including the version (e.g., from `Cargo.toml`) would help track which deployer version generated a config. However, this adds complexity and is not critical for the initial AI discoverability goal.
   - Potential format: `# Deployer Version: {{ metadata.deployer_version }}`
   - Would require version injection across all contexts
   - Deferred until there's a clear use case
